<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
====================================================================
 * This source code, its documentation and all appendant files
 * are protected by copyright law. All rights reserved.
 *
 * Copyright, 2003 - 2007
 * University of Konstanz, Germany
 * Chair for Bioinformatics and Information Mining (Prof. M. Berthold)
 * and KNIME GmbH, Konstanz, Germany
 *
 * You may not modify, publish, transmit, transfer or sell, reproduce,
 * create derivative works from, distribute, perform, display, or in
 * any way exploit any of the content, in whole or in part, except as
 * otherwise expressly permitted in writing by the copyright owner or
 * as specified in the license file distributed with this product.
 *
 * If you have any questions please contact the copyright holder:
 * website: www.knime.org
 * email: contact@knime.org
====================================================================
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<title>Howto write a meta node</title>
</head>
<body>
<h1 align="center">Howto write a meta node</h1>
<p>Meta nodes are a useful concept inside KNIME workflows if you want to
execute parts of the workflow repeatedly. Existing examples are the Cross
validation node and the looper which both execute the internal workflow multiple
times and aggreate the results of each iteration in some way. Of course, meta
nodes can also be used to just encapsulate the internal workflow to make the
outer one less complicated.</p>


Implementing your own meta node is quite simple:
<ol>
  <li>Create a subclass of <code>org.knime.core.meta.MetaNodeModel</code>.</li>
  <li>If the output data table spec is known in advance, override the <code>configure</code>
  method. Otherwise the output spec from the inner meta output node is taken. Of
  course, this only works, if the inner workflow is fully connected. Otherwise <code>null</code>
  will be returned (the node is not executable anyway).</li>
  <li>If you need to load and save settings (which in most cases you will),
  override the <code>loadValidatedSettingsFrom</code> and <code>saveSettingsTo</code>
  methods, but <b>make sure to call the super implementation</b> at the
  beginning. In addition to the standard load and save methods the ones from the
  meta node model have the node directory as parameter. You can use this to
  store additional information about your inner workflow there. The cross
  validation node, for example, stores the id of the partitioner node there.
  This is necessary, because you cannot store such internal information inside
  the <code>NodeSettings</code>, because they will get lost if the node dialog
  is used.</li>
  <li>If your internal workflow contains some predefined nodes that you
  need to configure in some way (e.g. like the partitioner in the cross
  validation node), you have to take some extra steps:
  <ol>
    <li>Upon creating the meta node for the first time, these mandatory
    inner nodes have to be added to the workflow inside the <code>addInternalNodes</code>
    methods. The internal workflow manager can be accessed by calling <code>internalWFM</code>.</li>
    <li>Likewise the connection between the meta input or output nodes must
    be added in <code>addInternalConnections</code>. <b>Make sure that in both
    cases you call the superclass implementation</b> at the beginning.</li>
    <li>If the node is loaded back from disk the special nodes and
    connections are created by the workflow manager.</li>
    <li>In both cases you may want to get your hands on the model inside
    these special nodes. For this, you have to call <code>retrieveModel</code>
    and pass <code>this</code> as arguments (in <code>addInternalNodes</code>
    and <code> loadValidatedSettingsFrom</code>, see the cross validation node
    for an example). In the end this calls <code>receiveModel</code> inside your
    meta node model with the desired node model as argument. Again, <b>make sure,
    that you call the superclass implementation</b> at the beginning of <code>receiveModel</code>.
    Now you only need to assign the received model to the proper member
    variable, but that's your task.</li>
    <li>By the way, you cannot use <code>save/loadInternals</code> for
    storing the id of the special nodes, because these methods will only be
    called if the node was executed upon saving the workflow.</li>
  </ol>
  </li>
  <li>Inside execute almost everything goes as usual. Only if you want to
  execute the internal workflow multiple times, you should call <code>resetAndConfigureAll</code>
  on the internal workflow manager before executing the internal workflow.</li>
  <li>For executing the internal workflow, it is advisable to use the
  following code snippet:
  <pre>
     KNIMEConstants.GLOBAL_THREAD_POOL.runInvisible(new Runnable() {
         public void run() {
             internalWFM().executeAll(true);
         }
     });
  </pre>
  This takes care that the thread in which the meta node runs (and which does
  nothing but wait for the internal workflow to execute) is not counted as a
  running thread inside KNIME. Otherwise your internal workflow may not execute
  at all, because no free thread is available (you can set the number of threads
  that KNIME should you in the global preferences).</li>
  <li>The results of the internal workflow are accessible at the meta
  output nodes. You can access them by calling <code>dataOutModel</code> for
  data output nodes or <code>modelOutModel</code> code for model output node,
  respectively.</li>
</ol>
And that's it! If you are still a bit unsure about how to do it, have a look at
the cross validation node. It creates a special partitioner node (that is
flagged non-deleted in its constructor), executes the internal workflow a
certain number of times and collectes the results of each iteration from the
meta output node.

</body>
</html>
